<!DOCTYPE html>
<html>

<head>
    <title>Web Pong</title>
    <meta charset="UTF-8">
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: rgb(29, 29, 29);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        #modal button {
            padding: 10px 20px;
            background-color: rgb(71, 71, 71);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <!-- TODO: Dynamic Canvas Sizing -->
    <div id="canvas-container">
    </div>

    <div id="modal">
        <p id="opponentMessage" style="display:none">Your opponent has disconnected!</p>
        <button id="findOpponentBtn" onclick="findOpponent()">Find New Opponent</button>
        <h2 style="font-family: 'Arial', sans-serif;" id="searchingMsg"> Searching for Opponent...</h2>
    </div>
    
</body>

<!-- Define Basic Pong Elements -->
<script>
    function openModal() {
        document.getElementById("modal").style.display = "block";
        document.getElementById("findOpponentBtn").style.display = "initial";
        document.getElementById("opponentMessage").style.display = "block";
        document.getElementById("searchingMsg").style.display = "none";
    }
    function findOpponent() {
        document.getElementById("modal").style.display = "block";
        document.getElementById("findOpponentBtn").style.display = "none";
        document.getElementById("searchingMsg").style.display = "initial";

        sendServerMessage({
            "trigger": "find_opponent"
        });
    }
    function foundOpponent() {
        document.getElementById("modal").style.display = "none";
    }
    const Key = {
        UP: 38,
        DOWN: 40,
        LEFT: 37,
        RIGHT: 39,
        W: 69,
        A: 65,
        S: 83,
        D: 68
    };
    const keyStates = 
    {
        up: false,
        down: false
        /*UP: false,
        DOWN: false,
        LEFT: false,
        RIGHT: false,
        W: false,
        A: false,
        S: false,
        D: false*/
    }

    //Initialize Canvas proportional to loaded screensize
    //Scale components by canvas size (relative to default height 996px)
    canvas_scaling = window.innerHeight / 996;
    const canvas_container = document.getElementById("canvas-container");
    canvas_container.innerHTML = `<canvas width="${window.innerHeight * 1}" height="${window.innerHeight * 0.8}" id="game"></canvas> `;
    const canvas = document.getElementById('game');
    const context = canvas.getContext('2d');

    //Initialize component attributes
    const thickness = 15 * canvas_scaling;
    const paddleHeight = thickness * 30; // 5 is default 
    const maxPaddleY = canvas.height - thickness - paddleHeight;

    var paddleSpeed = 6 * canvas_scaling; // 6 is default
    var ballSpeed = 6 * canvas_scaling; // 6 is default

    //Information about gameplay elements from opponent(s)
    var most_recent_external_gamestate = null;

    const ball = {
        xPos: canvas.width / 2, // middle of the board
        yPos: canvas.height / 2,
        xVel: ballSpeed,
        yVel: -ballSpeed,
        width: thickness,
        height: thickness,
        
        // keep track of when need to reset the ball position
        resetting: false,
    };

    const leftPaddle = {
        xPos: thickness * 2, // offset from left side of the screen
        yPos: (canvas.height / 2) - (paddleHeight / 2), // start at middle of the screen vertically
        yVel: 0,
        width: thickness,
        height: paddleHeight,
    };

    const rightPaddle = {
        xPos: canvas.width - (thickness * 3), // offset from right side of the screen
        yPos: (canvas.height / 2) - (paddleHeight / 2), // start at middle of the screen vertically
        yVel: 0,
        width: thickness,
        height: paddleHeight,
    };

    //Gamestate Flags
    var player_number = -1;
    var ball_in_localplayer_court = false;
    var localplayer_paddle_collision_this_frame = false;
    var opponent_scored = false;
    var ball_reset_complete = false;
    var myPaddle = null;
    

</script>

<!-- Handle Gameplay Physics Render Loop -->
<script>


    var last_rendered_timestamp = 0;
    const refresh_rate = 60;

    function collides(rect1, rect2) {
        return rect1.xPos < rect2.xPos + rect2.width &&
            rect1.xPos + rect1.width > rect2.xPos &&
            rect1.yPos < rect2.yPos + rect2.height &&
            rect1.yPos + rect1.height > rect2.yPos;
    }

    function renderFrame(cur_time) {
        if (player_number == -1)
            return;

        requestAnimationFrame(renderFrame); //prepare render of next frame as soon as next refresh occurs

        //New frame, any existing collision or scores has been resolved already 
        localplayer_paddle_collision_this_frame = false;
        opponent_scored = false;

        //Idenfity time scaling factor based on how much time has passed between frames
        //Ideal time between rendering frames should be 16.667ms or 60hz
        //Therefore if the difference between frames is 16.667ms then the scaling factor should = 1
        //If the difference between frames is LESS than 16.667ms, then the scaling factor should be < 1
        time_since_last_rendered = cur_time - last_rendered_timestamp
        time_scaling = (time_since_last_rendered) / (1000 * (1 / refresh_rate));
        // console.log("Cur: "+ cur_time + " Prev:" + last_rendered_timestamp + " Diff:" + (time_since_last_rendered));

        last_rendered_timestamp = cur_time; //update timestamp of last rendered frame (this frame) ((would be more intuitive to put this line of code at the end of this function))
        // console.log(time_scaling);

        //Compute Physics for Local Player Only

        //myPaddle.yPos+= myPaddle.yVel * time_scaling;

        if (keyStates.up)
            myPaddle.yPos -= paddleSpeed*time_scaling;
        if (keyStates.down)
            myPaddle.yPos += paddleSpeed*time_scaling;

        // prevent paddles from going through walls
        if (myPaddle.yPos < thickness) {
            myPaddle.yPos = thickness;
        }
        else if (myPaddle.yPos > maxPaddleY) {
            myPaddle.yPos = maxPaddleY;
        }


        //Handle Ball-Paddle Collision on this frame
        // check to see if ball collides with paddle. if they do change x velocity
        if (collides(ball, myPaddle)) {
            localplayer_paddle_collision_this_frame = true;
            ball.xVel *= -1;

            // move ball next to the paddle otherwise the collision will happen again
            // in the next frame
            ball.xPos = myPaddle.xPos;
            if (player_number == 0)
                ball.xPos += myPaddle.width;
            else
                ball.xPos -= myPaddle.width;
        }

        //Handle Ball Movement
        // move ball by its velocity 
        ball.xPos += ball.xVel * time_scaling;
        ball.yPos += ball.yVel * time_scaling;
        // console.log("Momentary Velocity: " + ball.xVel * time_scaling / (time_since_last_rendered)); //Distance traveled / time elapsed = velocity (speed)

        // prevent ball from going through walls by changing its velocity
        if (ball.yPos < thickness) {
            ball.yPos = thickness;
            ball.yVel *= -1;
        }
        else if (ball.yPos + thickness > canvas.height - thickness) {
            ball.yPos = canvas.height - thickness * 2;
            ball.yVel *= -1;
        }

        // reset ball if it goes past paddle (but only if we haven't already done so)
        //Also ensure that we are the ones in control of the ball (otherwise it is the opponents job to reset if they got scored on)
        if ((ball.xPos < 0 || ball.xPos > canvas.width) && !ball.resetting && ball_in_localplayer_court) {
            ball.resetting = true;
            opponent_scored = true;

            setTimeout(() => {
                ball.resetting = false;
                
                ball_reset_complete = true; //gamestate that ball has repositioned and reset is complete

                //Determine new ball trajectory
                ball.xPos = canvas.width / 2;
                ball.yPos = canvas.height / 2;
                //add randomness factor to ball velocity
                //TODO: Ball always has downwards vertical velocity when reset - will want to randomize that 
                // vertical_directional_scaling = Math.random()*ballSpeed/2 //Larger = More velocity in the vertical component
                // ball.dy = ballSpeed/2 + vertical_directional_scaling; //Vertical velocity 50-100% of normal
                // ball.dx = ballSpeed/2 + (1-vertical_directional_scaling) //Horizontal velocity is inverse-proportional to change in vertical velocity

            }, 500);
        }


        //Handle Component Visual Render
        context.clearRect(0, 0, canvas.width, canvas.height);

        // draw paddles

        context.fillStyle = 'white';
        context.fillRect(leftPaddle.xPos, leftPaddle.yPos, leftPaddle.width, leftPaddle.height);
        context.fillRect(rightPaddle.xPos, rightPaddle.yPos, rightPaddle.width, rightPaddle.height);

        // draw ball
        context.fillRect(ball.xPos, ball.yPos, ball.width, ball.height);

        // draw walls
        context.fillStyle = 'lightgrey';
        context.fillRect(0, 0, canvas.width, thickness);
        context.fillRect(0, canvas.height - thickness, canvas.width, canvas.height);

        // draw dotted line down the middle
        for (let i = thickness; i < canvas.height - thickness; i += thickness * 2) {
            context.fillRect(canvas.width / 2 - thickness / 4, i, thickness / 2, thickness);
        }



    //Send local updates (gamestate to opponent)
        if (ball_reset_complete == true) //send instance of the game with the updated ball reset position
        {
            local_gamestate = getGamestate(player_number);
            ball_reset_complete = false;
        }
        else{
            local_gamestate = getGamestate(player_number);
        }

        sendClientMessage({
            "trigger": "external_gamestate",
            "body": local_gamestate
        });

                    

    //Handle external gamestate (gamestate from opponent)
        if (most_recent_external_gamestate != null){ 
            handleExternalGamestate(most_recent_external_gamestate);
            most_recent_external_gamestate = null;
        }

        if (localplayer_paddle_collision_this_frame) {
            ball_in_localplayer_court = false; //we just hit the ball, pass off ball control to opponent
        }
    }


</script>

<!-- Handle User Input -->
<script>
    // Set Paddle Velocity > 0 if a key is pressed
    document.addEventListener('keydown', function (e) {
        if (!e.repeat) {

            // up arrow key
            if (e.which === Key.UP || e.which === Key.W) {
                //myPaddle.yVel-=paddleSpeed;
                keyStates.up = true;
            }
            // down arrow key
            else if (e.which === Key.DOWN || e.which == Key.S) {
                keyStates.down = true;
                //myPaddle.yVel+=paddleSpeed;
            }
            console.log("KEY DOWN !!");
        }
    });

    // Set Paddle Velocity == 0 if pressed key is letgo
    document.addEventListener('keyup', function (e) {
        if (!e.repeat) {

            if (e.which === Key.UP || e.which === Key.W) {
                //myPaddle.yVel+=paddleSpeed;
                keyStates.up = false;
            }
            // down arrow key
            else if (e.which === Key.DOWN || e.which == Key.S) {
                keyStates.down = false;
                //myPaddle.yVel-=paddleSpeed;
            }
            console.log("KEY UP !!");
        }

    });

</script>

<!-- Package and Unpack Gamestate for networking purposes -->
<script>
    //Gets current state of gameplay elements (local to player) and puts the information in an object
    function getGamestate(player_num) {
        switch (player_num) {
            case 0:
                gamestate = {
                    //paddle-ball collision occurred 
                    opponent_paddle_ball_collision: localplayer_paddle_collision_this_frame, //opponent will see this local collision as collision from *their* opponent 
                    //local player paddle y abs position
                    left_paddle_y_pos: leftPaddle.yPos / canvas_scaling, //divide out canvas scaling so when we are using standardized values (two users with different canvas sizes will recieve/send similar values)
                    //local player paddle y abs position
                    left_paddle_y_vel: leftPaddle.yVel / canvas_scaling,
                    //ball abs position
                    ball_y_pos: ball.yPos / canvas_scaling,
                    ball_x_pos: ball.xPos / canvas_scaling,
                    //ball x,y abs velocity
                    ball_y_vel: ball.yVel / canvas_scaling,
                    ball_x_vel: ball.xVel / canvas_scaling,
                    //ball was reset
                    ball_has_reset: ball_reset_complete,
                    //scoring event
                    local_scored: opponent_scored,
                }
                break;
            case 1:
                gamestate = {
                    //paddle-ball collision occurred 
                    opponent_paddle_ball_collision: localplayer_paddle_collision_this_frame, //opponent will see this local collision as collision from *their* opponent 
                    //local player paddle y abs position
                    right_paddle_y_pos: rightPaddle.yPos/ canvas_scaling,
                    //local player paddle y abs position
                    right_paddle_x_vel: rightPaddle.yVel / canvas_scaling,
                    //ball abs position
                    ball_y_pos: ball.yPos / canvas_scaling,
                    ball_x_pos: ball.xPos / canvas_scaling,
                    //ball x,y abs velocity
                    ball_y_vel: ball.yVel / canvas_scaling,
                    ball_x_vel: ball.xVel / canvas_scaling,
                    //ball was reset
                    ball_has_reset: ball_reset_complete,
                    //scoring event
                    local_scored: opponent_scored,
                }
                break;
            default:
                console.log("Unknown player #, cannot get gamestate")
                return null;
        }


        return gamestate;
    }

    //Takes in a gamestate object and compares it to local gamestate
    //Handles logic of deciding which gamestate will be rendered in the current frame. 
    //Call this function whenever a new gamestate object arrives from network protocol
    function handleExternalGamestate(external_gamestate) {
        //Only modify state of ball when a collision has occurred from opponent or ball is resetting on opponents side due to scoring on them
            //otherwise, render game logic as normal, but always update opponents paddle
        if (external_gamestate.opponent_paddle_ball_collision == true)
        {
            console.log("(opposing) collision occurred, render based on opponents gamestate");

            //Modify local gamestate to match incoming gamestate from opponent
            //(Remember to scale by local canvas size)
            //Ball
            ball.xPos = (external_gamestate.ball_x_pos) * canvas_scaling;
            ball.yPos = external_gamestate.ball_y_pos * canvas_scaling;
            ball.xVel = external_gamestate.ball_x_vel * canvas_scaling;
            ball.yVel = external_gamestate.ball_y_vel * canvas_scaling;
            ball_in_localplayer_court = true; // Opponent hit ball towards local player
        }
        else if (external_gamestate.ball_has_reset == true)
        {
            console.log("Ball reset triggered; Most likely due to scoring"
            + "\nrender based on opponent's ball reset position; they still have control of ball"); 
            
        //Modify local gamestate to match incoming gamestate from opponent
        //(Remember to scale by local canvas size)
            //Ball
            ball.xPos = (external_gamestate.ball_x_pos) * canvas_scaling;
            ball.yPos = external_gamestate.ball_y_pos * canvas_scaling;
            ball.xVel = external_gamestate.ball_x_vel * canvas_scaling;
            ball.yVel = external_gamestate.ball_y_vel * canvas_scaling;
            ball_in_localplayer_court = false; //Opponent still has ball
        }


        console.log("retain gamestate, but update paddle always");

        //(Opponents) Paddle
        if (player_number == 0) //opponent is p1, their side is right
        {
            rightPaddle.yPos= (external_gamestate.right_paddle_y_pos) * canvas_scaling;
            right_paddle_y_vel = external_gamestate.right_paddle_y_vel * canvas_scaling;
        }
        else //opponent is p0, their side is left
        {

            
        }

        //TODO: HANDLE SCORING EVENT HERE
        if (external_gamestate.local_scored){ 
                                              //Triggered whenenever we score, not when we get scored on 
            console.log("We just scored on opponent; (track our score)");
        }

        //TODO: HANDLE SCORING EVENT HERE
        if (external_gamestate.local_scored){ 
                                              //Triggered whenenever we score, not when we get scored on 
            console.log("We just scored on opponent; (track our score)");
        }

    }


</script>


<!-- WEBSOCKET MESSAGE HANDLING -->
<script>
    var fake_lag = 0; //(20 frames of fake latency between opponents)
    var gamestate_lag_queue = [];


    const ws = new WebSocket("ws://localhost:8080");
    ws.addEventListener("open", (event) => {
        ws.binaryType = "arraybuffer";
        findOpponent();
    });

    //Listening for messages coming through this websocket
    ws.addEventListener("message", async (event) => {
        // message_raw = event.data;
        // console.log(message_raw);
        message_obj = JSON.parse(event.data.substring(1));


        //If message is from opponents newest gamestate
        if (message_obj["trigger"] == "external_gamestate") {
            gamestate_lag_queue.push(message_obj["body"]);
            if (gamestate_lag_queue.length >= fake_lag) {
                most_recent_external_gamestate = gamestate_lag_queue.shift();
            }
            if (message_obj["debug_message"]){
                console.log(message_obj["debug_message"]);
            }
            // most_recent_external_gamestate = message_obj["body"]
        }
        //If message is connection established
        else if (message_obj["trigger"] == "connection_established") {
            foundOpponent();
            console.log("connection established");
            console.log(message_obj);
            player_number = message_obj["body"]["player_num"]
            if (player_number == 1) { //ball starts off going to right side
                ball_in_localplayer_court = true;

                myPaddle = rightPaddle; // player 1 gets right paddle
            }
            else {
                myPaddle = leftPaddle; // player 0 gets left paddle
            }

            // start the game now
            requestAnimationFrame(renderFrame);
        }
        else if (message_obj["trigger"] == "opponent_disconnected") {
            console.log("opponent disconnected");
            console.log(message_obj);
            player_number = -1;
            openModal();
        }

    });


    //Functions for sending messages to websocket
    //Call if data needs to be sent to connected client
    function sendClientMessage(msg) {
        //console.log(document.getElementById('message-input').value);
        ws.send("c" + JSON.stringify(msg));
        //ws.send(.toString());
    }

    //Call if data needs to be sent to server
    function sendServerMessage(msg) {
        //console.log(document.getElementById('message-input').value);
        ws.send("s" + JSON.stringify(msg));
        //ws.send(.toString());
    }


    
</script>


</html>